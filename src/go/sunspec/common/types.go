// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package common

import "encoding/json"
import "fmt"
import "reflect"

type Group struct {
	// Comments corresponds to the JSON schema field "comments".
	Comments []string `json:"comments,omitempty" yaml:"comments,omitempty" mapstructure:"comments,omitempty"`

	// Count corresponds to the JSON schema field "count".
	Count interface{} `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Desc corresponds to the JSON schema field "desc".
	Desc *string `json:"desc,omitempty" yaml:"desc,omitempty" mapstructure:"desc,omitempty"`

	// Detail corresponds to the JSON schema field "detail".
	Detail *string `json:"detail,omitempty" yaml:"detail,omitempty" mapstructure:"detail,omitempty"`

	// Groups corresponds to the JSON schema field "groups".
	Groups []Group `json:"groups,omitempty" yaml:"groups,omitempty" mapstructure:"groups,omitempty"`

	// Label corresponds to the JSON schema field "label".
	Label *string `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Notes corresponds to the JSON schema field "notes".
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// Points corresponds to the JSON schema field "points".
	Points []Point `json:"points,omitempty" yaml:"points,omitempty" mapstructure:"points,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type GroupType `json:"type" yaml:"type" mapstructure:"type"`
}

type GroupType string

const GroupTypeGroup GroupType = "group"
const GroupTypeSync GroupType = "sync"

var enumValues_GroupType = []interface{}{
	"group",
	"sync",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GroupType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GroupType, v)
	}
	*j = GroupType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Group) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Group: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Group: required")
	}
	type Plain Group
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		plain.Count = 1.0
	}
	*j = Group(plain)
	return nil
}

type Point struct {
	// Access corresponds to the JSON schema field "access".
	Access PointAccess `json:"access,omitempty" yaml:"access,omitempty" mapstructure:"access,omitempty"`

	// Comments corresponds to the JSON schema field "comments".
	Comments []string `json:"comments,omitempty" yaml:"comments,omitempty" mapstructure:"comments,omitempty"`

	// Count corresponds to the JSON schema field "count".
	Count *int `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Desc corresponds to the JSON schema field "desc".
	Desc *string `json:"desc,omitempty" yaml:"desc,omitempty" mapstructure:"desc,omitempty"`

	// Detail corresponds to the JSON schema field "detail".
	Detail *string `json:"detail,omitempty" yaml:"detail,omitempty" mapstructure:"detail,omitempty"`

	// Label corresponds to the JSON schema field "label".
	Label *string `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// Mandatory corresponds to the JSON schema field "mandatory".
	Mandatory PointMandatory `json:"mandatory,omitempty" yaml:"mandatory,omitempty" mapstructure:"mandatory,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Notes corresponds to the JSON schema field "notes".
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// Sf corresponds to the JSON schema field "sf".
	Sf interface{} `json:"sf,omitempty" yaml:"sf,omitempty" mapstructure:"sf,omitempty"`

	// Size corresponds to the JSON schema field "size".
	Size int `json:"size" yaml:"size" mapstructure:"size"`

	// Static corresponds to the JSON schema field "static".
	Static PointStatic `json:"static,omitempty" yaml:"static,omitempty" mapstructure:"static,omitempty"`

	// Symbols corresponds to the JSON schema field "symbols".
	Symbols []Symbol `json:"symbols,omitempty" yaml:"symbols,omitempty" mapstructure:"symbols,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type PointType `json:"type" yaml:"type" mapstructure:"type"`

	// Units corresponds to the JSON schema field "units".
	Units *string `json:"units,omitempty" yaml:"units,omitempty" mapstructure:"units,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value interface{} `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type PointAccess string

const PointAccessR PointAccess = "R"
const PointAccessRW PointAccess = "RW"

var enumValues_PointAccess = []interface{}{
	"R",
	"RW",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PointAccess) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PointAccess {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PointAccess, v)
	}
	*j = PointAccess(v)
	return nil
}

type PointMandatory string

const PointMandatoryM PointMandatory = "M"
const PointMandatoryO PointMandatory = "O"

var enumValues_PointMandatory = []interface{}{
	"M",
	"O",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PointMandatory) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PointMandatory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PointMandatory, v)
	}
	*j = PointMandatory(v)
	return nil
}

type PointStatic string

const PointStaticD PointStatic = "D"
const PointStaticS PointStatic = "S"

var enumValues_PointStatic = []interface{}{
	"D",
	"S",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PointStatic) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PointStatic {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PointStatic, v)
	}
	*j = PointStatic(v)
	return nil
}

type PointType string

const PointTypeAcc16 PointType = "acc16"
const PointTypeAcc32 PointType = "acc32"
const PointTypeAcc64 PointType = "acc64"
const PointTypeBitfield16 PointType = "bitfield16"
const PointTypeBitfield32 PointType = "bitfield32"
const PointTypeBitfield64 PointType = "bitfield64"
const PointTypeCount PointType = "count"
const PointTypeEnum16 PointType = "enum16"
const PointTypeEnum32 PointType = "enum32"
const PointTypeEui48 PointType = "eui48"
const PointTypeFloat32 PointType = "float32"
const PointTypeFloat64 PointType = "float64"
const PointTypeInt16 PointType = "int16"
const PointTypeInt32 PointType = "int32"
const PointTypeInt64 PointType = "int64"
const PointTypeIpaddr PointType = "ipaddr"
const PointTypeIpv6Addr PointType = "ipv6addr"
const PointTypePad PointType = "pad"
const PointTypeRaw16 PointType = "raw16"
const PointTypeSf PointType = "sf"
const PointTypeString PointType = "string"
const PointTypeSunssf PointType = "sunssf"
const PointTypeUint16 PointType = "uint16"
const PointTypeUint32 PointType = "uint32"
const PointTypeUint64 PointType = "uint64"

var enumValues_PointType = []interface{}{
	"int16",
	"int32",
	"int64",
	"raw16",
	"uint16",
	"uint32",
	"uint64",
	"acc16",
	"acc32",
	"acc64",
	"bitfield16",
	"bitfield32",
	"bitfield64",
	"enum16",
	"enum32",
	"float32",
	"float64",
	"string",
	"sf",
	"pad",
	"ipaddr",
	"ipv6addr",
	"eui48",
	"sunssf",
	"count",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PointType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PointType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PointType, v)
	}
	*j = PointType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Point) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Point: required")
	}
	if _, ok := raw["size"]; raw != nil && !ok {
		return fmt.Errorf("field size in Point: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Point: required")
	}
	type Plain Point
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["access"]; !ok || v == nil {
		plain.Access = "R"
	}
	if v, ok := raw["mandatory"]; !ok || v == nil {
		plain.Mandatory = "O"
	}
	if v, ok := raw["static"]; !ok || v == nil {
		plain.Static = "D"
	}
	*j = Point(plain)
	return nil
}

// JSON Schema for SunSpec information model definition
type SchemaJson struct {
	// Comments corresponds to the JSON schema field "comments".
	Comments []string `json:"comments,omitempty" yaml:"comments,omitempty" mapstructure:"comments,omitempty"`

	// Desc corresponds to the JSON schema field "desc".
	Desc *string `json:"desc,omitempty" yaml:"desc,omitempty" mapstructure:"desc,omitempty"`

	// Detail corresponds to the JSON schema field "detail".
	Detail *string `json:"detail,omitempty" yaml:"detail,omitempty" mapstructure:"detail,omitempty"`

	// Group corresponds to the JSON schema field "group".
	Group Group `json:"group" yaml:"group" mapstructure:"group"`

	// Id corresponds to the JSON schema field "id".
	Id int `json:"id" yaml:"id" mapstructure:"id"`

	// Label corresponds to the JSON schema field "label".
	Label *string `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// Notes corresponds to the JSON schema field "notes".
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["group"]; raw != nil && !ok {
		return fmt.Errorf("field group in SchemaJson: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SchemaJson: required")
	}
	type Plain SchemaJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if 65535 < plain.Id {
		return fmt.Errorf("field %s: must be <= %v", "id", 65535)
	}
	if 1 > plain.Id {
		return fmt.Errorf("field %s: must be >= %v", "id", 1)
	}
	*j = SchemaJson(plain)
	return nil
}

type Symbol struct {
	// Comments corresponds to the JSON schema field "comments".
	Comments []string `json:"comments,omitempty" yaml:"comments,omitempty" mapstructure:"comments,omitempty"`

	// Desc corresponds to the JSON schema field "desc".
	Desc *string `json:"desc,omitempty" yaml:"desc,omitempty" mapstructure:"desc,omitempty"`

	// Detail corresponds to the JSON schema field "detail".
	Detail *string `json:"detail,omitempty" yaml:"detail,omitempty" mapstructure:"detail,omitempty"`

	// Label corresponds to the JSON schema field "label".
	Label *string `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Notes corresponds to the JSON schema field "notes".
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value interface{} `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Symbol) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Symbol: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in Symbol: required")
	}
	type Plain Symbol
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Symbol(plain)
	return nil
}
